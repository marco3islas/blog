[{"model": "admin.logentry", "pk": 1, "fields": {"action_time": "2024-11-20T00:57:41.201Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Article object (1)", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 2, "fields": {"action_time": "2024-11-20T04:55:13.751Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 3, "fields": {"action_time": "2024-11-20T19:06:39.528Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Angular 19 novedades y mejoras.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Article\"]}}]"}}, {"model": "admin.logentry", "pk": 4, "fields": {"action_time": "2024-11-20T19:17:33.797Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Angular 19 novedades y mejoras.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Resumen\"]}}]"}}, {"model": "admin.logentry", "pk": 5, "fields": {"action_time": "2024-11-20T19:18:48.776Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Angular 19 novedades y mejoras.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Resumen\"]}}]"}}, {"model": "admin.logentry", "pk": 6, "fields": {"action_time": "2024-11-21T16:09:02.846Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Article\"]}}]"}}, {"model": "admin.logentry", "pk": 7, "fields": {"action_time": "2024-11-21T16:19:06.814Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Article\"]}}]"}}, {"model": "admin.logentry", "pk": 8, "fields": {"action_time": "2024-11-22T04:24:31.586Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Angular Standalone components.", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 9, "fields": {"action_time": "2024-12-30T17:42:18.096Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Angular Standalone components.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 10, "fields": {"action_time": "2024-12-30T17:43:01.381Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Angular Standalone components.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 11, "fields": {"action_time": "2024-12-30T17:44:10.325Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 12, "fields": {"action_time": "2024-12-30T18:28:15.047Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 13, "fields": {"action_time": "2024-12-30T18:29:13.792Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Image\"]}}]"}}, {"model": "admin.logentry", "pk": 14, "fields": {"action_time": "2024-12-30T18:50:27.311Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Image\"]}}]"}}, {"model": "admin.logentry", "pk": 15, "fields": {"action_time": "2024-12-30T19:26:30.588Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Angular 19 novedades y mejoras.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\", \"Image\"]}}]"}}, {"model": "admin.logentry", "pk": 16, "fields": {"action_time": "2024-12-30T19:30:56.020Z", "user": 1, "content_type": 7, "object_id": "2", "object_repr": "¿Qué son los Signals?", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 17, "fields": {"action_time": "2024-12-30T20:09:00.389Z", "user": 1, "content_type": 7, "object_id": "1", "object_repr": "Angular 19 novedades y mejoras.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 18, "fields": {"action_time": "2024-12-30T20:15:11.715Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Angular Standalone components.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 19, "fields": {"action_time": "2024-12-30T22:28:30.804Z", "user": 1, "content_type": 7, "object_id": "4", "object_repr": "React", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 20, "fields": {"action_time": "2024-12-30T23:35:45.430Z", "user": 1, "content_type": 7, "object_id": "3", "object_repr": "Angular Standalone components.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Image\"]}}]"}}, {"model": "admin.logentry", "pk": 21, "fields": {"action_time": "2024-12-31T00:01:24.976Z", "user": 1, "content_type": 7, "object_id": "5", "object_repr": "Streamlit el Framework de Python ideal para: Data Science, IA y ML", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 22, "fields": {"action_time": "2024-12-31T00:02:49.662Z", "user": 1, "content_type": 7, "object_id": "5", "object_repr": "Streamlit el Framework de Python ideal para: Data Science, IA y ML", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Resumen\"]}}]"}}, {"model": "admin.logentry", "pk": 23, "fields": {"action_time": "2025-01-09T17:01:38.042Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Los 3 principales métodos de recomendación:", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 24, "fields": {"action_time": "2025-01-09T17:04:27.948Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Los 3 principales métodos de recomendación:", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 25, "fields": {"action_time": "2025-01-09T17:30:58.134Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Los 3 principales métodos de recomendación:", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 26, "fields": {"action_time": "2025-01-09T17:34:27.962Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Los 3 principales métodos de recomendación:", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 27, "fields": {"action_time": "2025-01-09T17:36:16.739Z", "user": 1, "content_type": 7, "object_id": "6", "object_repr": "Los 3 principales métodos de recomendación:", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\"]}}]"}}, {"model": "admin.logentry", "pk": 28, "fields": {"action_time": "2025-02-05T03:11:01.101Z", "user": 1, "content_type": 7, "object_id": "7", "object_repr": "Herramientas de Pruebas de API.", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "admin.logentry", "pk": 29, "fields": {"action_time": "2025-02-05T04:21:48.369Z", "user": 1, "content_type": 7, "object_id": "7", "object_repr": "Herramientas de Pruebas de API.", "action_flag": 2, "change_message": "[{\"changed\": {\"fields\": [\"Text\", \"Image\"]}}]"}}, {"model": "admin.logentry", "pk": 30, "fields": {"action_time": "2025-02-26T18:18:08.066Z", "user": 1, "content_type": 7, "object_id": "8", "object_repr": "Diccionarios en Python vs Objetos en JavaScript", "action_flag": 1, "change_message": "[{\"added\": {}}]"}}, {"model": "auth.permission", "pk": 1, "fields": {"name": "Can add log entry", "content_type": 1, "codename": "add_logentry"}}, {"model": "auth.permission", "pk": 2, "fields": {"name": "Can change log entry", "content_type": 1, "codename": "change_logentry"}}, {"model": "auth.permission", "pk": 3, "fields": {"name": "Can delete log entry", "content_type": 1, "codename": "delete_logentry"}}, {"model": "auth.permission", "pk": 4, "fields": {"name": "Can view log entry", "content_type": 1, "codename": "view_logentry"}}, {"model": "auth.permission", "pk": 5, "fields": {"name": "Can add permission", "content_type": 2, "codename": "add_permission"}}, {"model": "auth.permission", "pk": 6, "fields": {"name": "Can change permission", "content_type": 2, "codename": "change_permission"}}, {"model": "auth.permission", "pk": 7, "fields": {"name": "Can delete permission", "content_type": 2, "codename": "delete_permission"}}, {"model": "auth.permission", "pk": 8, "fields": {"name": "Can view permission", "content_type": 2, "codename": "view_permission"}}, {"model": "auth.permission", "pk": 9, "fields": {"name": "Can add group", "content_type": 3, "codename": "add_group"}}, {"model": "auth.permission", "pk": 10, "fields": {"name": "Can change group", "content_type": 3, "codename": "change_group"}}, {"model": "auth.permission", "pk": 11, "fields": {"name": "Can delete group", "content_type": 3, "codename": "delete_group"}}, {"model": "auth.permission", "pk": 12, "fields": {"name": "Can view group", "content_type": 3, "codename": "view_group"}}, {"model": "auth.permission", "pk": 13, "fields": {"name": "Can add user", "content_type": 4, "codename": "add_user"}}, {"model": "auth.permission", "pk": 14, "fields": {"name": "Can change user", "content_type": 4, "codename": "change_user"}}, {"model": "auth.permission", "pk": 15, "fields": {"name": "Can delete user", "content_type": 4, "codename": "delete_user"}}, {"model": "auth.permission", "pk": 16, "fields": {"name": "Can view user", "content_type": 4, "codename": "view_user"}}, {"model": "auth.permission", "pk": 17, "fields": {"name": "Can add content type", "content_type": 5, "codename": "add_contenttype"}}, {"model": "auth.permission", "pk": 18, "fields": {"name": "Can change content type", "content_type": 5, "codename": "change_contenttype"}}, {"model": "auth.permission", "pk": 19, "fields": {"name": "Can delete content type", "content_type": 5, "codename": "delete_contenttype"}}, {"model": "auth.permission", "pk": 20, "fields": {"name": "Can view content type", "content_type": 5, "codename": "view_contenttype"}}, {"model": "auth.permission", "pk": 21, "fields": {"name": "Can add session", "content_type": 6, "codename": "add_session"}}, {"model": "auth.permission", "pk": 22, "fields": {"name": "Can change session", "content_type": 6, "codename": "change_session"}}, {"model": "auth.permission", "pk": 23, "fields": {"name": "Can delete session", "content_type": 6, "codename": "delete_session"}}, {"model": "auth.permission", "pk": 24, "fields": {"name": "Can view session", "content_type": 6, "codename": "view_session"}}, {"model": "auth.permission", "pk": 25, "fields": {"name": "Can add article", "content_type": 7, "codename": "add_article"}}, {"model": "auth.permission", "pk": 26, "fields": {"name": "Can change article", "content_type": 7, "codename": "change_article"}}, {"model": "auth.permission", "pk": 27, "fields": {"name": "Can delete article", "content_type": 7, "codename": "delete_article"}}, {"model": "auth.permission", "pk": 28, "fields": {"name": "Can view article", "content_type": 7, "codename": "view_article"}}, {"model": "auth.permission", "pk": 29, "fields": {"name": "Can add contacto", "content_type": 8, "codename": "add_contacto"}}, {"model": "auth.permission", "pk": 30, "fields": {"name": "Can change contacto", "content_type": 8, "codename": "change_contacto"}}, {"model": "auth.permission", "pk": 31, "fields": {"name": "Can delete contacto", "content_type": 8, "codename": "delete_contacto"}}, {"model": "auth.permission", "pk": 32, "fields": {"name": "Can view contacto", "content_type": 8, "codename": "view_contacto"}}, {"model": "auth.user", "pk": 1, "fields": {"password": "pbkdf2_sha256$870000$j6K0JedU9S77pSzMsaSJwS$otIatL9BjTHuOKJk95e4xuLjlzO8tsC+0ZaYj8MS0WM=", "last_login": "2025-02-26T18:04:54.568Z", "is_superuser": true, "username": "marco", "first_name": "", "last_name": "", "email": "marco3islas@gmail.com", "is_staff": true, "is_active": true, "date_joined": "2024-11-19T18:51:13.999Z", "groups": [], "user_permissions": []}}, {"model": "contenttypes.contenttype", "pk": 1, "fields": {"app_label": "admin", "model": "logentry"}}, {"model": "contenttypes.contenttype", "pk": 2, "fields": {"app_label": "auth", "model": "permission"}}, {"model": "contenttypes.contenttype", "pk": 3, "fields": {"app_label": "auth", "model": "group"}}, {"model": "contenttypes.contenttype", "pk": 4, "fields": {"app_label": "auth", "model": "user"}}, {"model": "contenttypes.contenttype", "pk": 5, "fields": {"app_label": "contenttypes", "model": "contenttype"}}, {"model": "contenttypes.contenttype", "pk": 6, "fields": {"app_label": "sessions", "model": "session"}}, {"model": "contenttypes.contenttype", "pk": 7, "fields": {"app_label": "blog_application", "model": "article"}}, {"model": "contenttypes.contenttype", "pk": 8, "fields": {"app_label": "blog_application", "model": "contacto"}}, {"model": "sessions.session", "pk": "32f92fexgkkh9ogbrm4cookkb1wittf9", "fields": {"session_data": ".eJxVjEEOwiAURO_C2hD4FSou3XuGZj4fpGpKUtqV8e7apAvdzntvXmrAupRhbWkeRlFnZdXhd2PER5o2IHdMt6pjnZZ5ZL0peqdNX6uk52V3_w4KWvnWbDN7ZuqIQQ4evRgxwAlBGB05yV56j-hwzGyi5BxtIPIhcXBM6v0BHL45Yg:1tVuzy:ng4WxB5gq9YbMMTJN7CUQ_OGQAI-6oVOjtykV3nXrSo", "expire_date": "2025-01-23T16:03:06.431Z"}}, {"model": "sessions.session", "pk": "3a5ao81ueaqa5o22krgowrx46p8acg3x", "fields": {"session_data": ".eJxVjEEOwiAURO_C2hD4FSou3XuGZj4fpGpKUtqV8e7apAvdzntvXmrAupRhbWkeRlFnZdXhd2PER5o2IHdMt6pjnZZ5ZL0peqdNX6uk52V3_w4KWvnWbDN7ZuqIQQ4evRgxwAlBGB05yV56j-hwzGyi5BxtIPIhcXBM6v0BHL45Yg:1tF3dV:6ydcNKYJMXRS51dFfkvm3MCYrr2tVyj3zASrdT20WKU", "expire_date": "2024-12-08T03:50:13.398Z"}}, {"model": "sessions.session", "pk": "48a29tzycznb7xm33a7dw3rn8rbu0j51", "fields": {"session_data": ".eJxVjEEOwiAURO_C2hD4FSou3XuGZj4fpGpKUtqV8e7apAvdzntvXmrAupRhbWkeRlFnZdXhd2PER5o2IHdMt6pjnZZ5ZL0peqdNX6uk52V3_w4KWvnWbDN7ZuqIQQ4evRgxwAlBGB05yV56j-hwzGyi5BxtIPIhcXBM6v0BHL45Yg:1tfV2t:6kdhs0ZTyytH1uwmQrqsS1tl7kiSBK8UXTWVU3u2ix0", "expire_date": "2025-02-19T02:21:43.327Z"}}, {"model": "sessions.session", "pk": "4bmvrot7r5852eeoltf47b2cd93x40m1", "fields": {"session_data": ".eJxVjEEOwiAURO_C2hD4FSou3XuGZj4fpGpKUtqV8e7apAvdzntvXmrAupRhbWkeRlFnZdXhd2PER5o2IHdMt6pjnZZ5ZL0peqdNX6uk52V3_w4KWvnWbDN7ZuqIQQ4evRgxwAlBGB05yV56j-hwzGyi5BxtIPIhcXBM6v0BHL45Yg:1tDTKb:CynN38aDJfACU7AwOzsf-egVbXw-tChDz2O3_R_lNCU", "expire_date": "2024-12-03T18:52:09.155Z"}}, {"model": "sessions.session", "pk": "5veti45gsq0gxx23bdwsxil9amtc6j9c", "fields": {"session_data": ".eJxVjEEOwiAURO_C2hD4FSou3XuGZj4fpGpKUtqV8e7apAvdzntvXmrAupRhbWkeRlFnZdXhd2PER5o2IHdMt6pjnZZ5ZL0peqdNX6uk52V3_w4KWvnWbDN7ZuqIQQ4evRgxwAlBGB05yV56j-hwzGyi5BxtIPIhcXBM6v0BHL45Yg:1tnLmA:rVOz3ppzGgdTZK1Uk1bD5Gj3Dz9Mh32b7LmInP4DPOs", "expire_date": "2025-03-12T18:04:54.680Z"}}, {"model": "sessions.session", "pk": "f767vafc9y6ei99gineu8weun8rbygzf", "fields": {"session_data": ".eJxVjEEOwiAURO_C2hD4FSou3XuGZj4fpGpKUtqV8e7apAvdzntvXmrAupRhbWkeRlFnZdXhd2PER5o2IHdMt6pjnZZ5ZL0peqdNX6uk52V3_w4KWvnWbDN7ZuqIQQ4evRgxwAlBGB05yV56j-hwzGyi5BxtIPIhcXBM6v0BHL45Yg:1tSJVe:Mkacyr-8SZ_drhgq0p9-M236EpKwCW_ohP_n2ZqfxnQ", "expire_date": "2025-01-13T17:24:54.670Z"}}, {"model": "blog_application.article", "pk": 1, "fields": {"title": "Angular 19 novedades y mejoras.", "subtitle": "Ya se ha lanzado la version 19 de Angular y trae consigo varias novedades.", "resumen": "Angular 19 trajo consigo una serie de mejoras y nuevas características diseñadas para optimizar el desarrollo y rendimiento...", "article": "<p>Angular 19, que está programado para lanzarse oficialmente en noviembre de 2024, trae varias novedades enfocadas en mejorar la experiencia del desarrollador y el rendimiento de las aplicaciones.</p><hr><p>Entre las características más destacadas se encuentran:</p><ul><li>I<strong>ntegración de Signals como modelo central de reactividad</strong>: Signals, que ya estaba en versión preliminar, se convertirá en una característica estable. Este cambio reducirá la dependencia de Zone.js, proporcionando un sistema más eficiente y predecible para manejar el estado reactivo​.</li><li><strong>Mejoras en la renderización del lado del servidor (SSR)</strong>: Angular 19 continuará refinando técnicas de hidratación parcial para optimizar tiempos de carga y métricas de rendimiento web. También se integrarán capacidades avanzadas de \"replay de eventos\" para mejorar la interacción inicial en aplicaciones renderizadas desde el servidor​.</li><li><strong> Standalone Components</strong> por defecto: Ahora no será necesario declarar explícitamente \"standalone: true\" en los componentes, lo que simplificará su configuración y uso, alineándose con la dirección de Angular hacia menos dependencias de NgModules​.</li><li> <strong>APIs de datos asincrónicos simplificadas:</strong> Se introducirán las APIs resource y rxResource para gestionar la recuperación de datos con promesas y Observables, ofreciendo un enfoque unificado y fácil de usar para manejar flujos de datos asincrónicos​ Ampliación del soporte para micro frontends: Nuevas configuraciones permitirán un manejo más granular de aplicaciones distribuidas, mejorando la integración de módulos independientes y la administración del estado global</li><li> <strong>Depuración y pruebas mejoradas</strong>: Se espera una integración más sólida de Jest como herramienta de prueba predeterminada, junto con utilidades para la gestión automática de imports no utilizados​ Angular 19 promete seguir haciendo de este framework una opción sólida tanto para desarrolladores principiantes como experimentados. Puedes leer más detalles en las fuentes que consulté: Dev.to y Mescius.</li></ul>", "author": "Marco", "fecha": "2024-11-20", "image": "images/angular.webp"}}, {"model": "blog_application.article", "pk": 2, "fields": {"title": "¿Qué son los Signals?", "subtitle": "", "resumen": "Los Signals son una forma de gestionar el estado reactivo en Angular, inspirada en bibliotecas como React y SolidJS.", "article": "<h1>Signals en Angular: Una Nueva Era en el Manejo del Estado</h1><p>Los Signals son una revolución en cómo Angular maneja el estado reactivo. Introducidos en Angular 16 como una caracteristica experimental, ofrecen una forma más eficiente y predecible de observar y reaccionar a los cambios en los valores. Este artículo explora qué son, cómo funcionan y por qué superan a Zone.js, el método tradicional de Angular para manejar el estado.</p><p>&nbsp;</p><hr><h3><br>¿Qué son los Signals?</h3><p>Un Signal es esencialmente una variable observable que permite rastrear su valor y ejecutar acciones específicas cuando este cambia. Su diseño busca resolver problemas de rendimiento y complejidad asociados con las técnicas tradicionales en Angular.</p><hr><h3><br>¿Cómo Funcionan?</h3><p>El funcionamiento de los Signals se puede dividir en cuatro pasos clave:</p><p>&nbsp; &nbsp; Declaración: Se crea un Signal con un valor inicial.</p><p>const counter = signal(0);</p><p>Observación: Se define una función de callback para observar los cambios en el Signal.</p><p>effect(() =&gt; console.log(counter()));</p><p>Actualización: Cuando el valor cambia, Angular notifica automáticamente a los observadores.</p><p>&nbsp; &nbsp; counter.set(counter() + 1);</p><p>&nbsp; &nbsp; Reacción: La función de callback actualiza la UI o ejecuta cualquier acción necesaria. Esto elimina la necesidad de realizar \"detecciones de cambios\" manuales.</p><hr><h3>¿Qué Pasa con Zone.js?</h3><p>Zone.js es la biblioteca que Angular ha utilizado tradicionalmente para detectar cambios en el estado de la aplicación y actualizar la UI. Sin embargo, presenta problemas como una mayor sobrecarga de procesamiento y la introducción de comportamientos impredecibles en aplicaciones complejas.<br><strong>Cambios en Angular 19:</strong></p><p>&nbsp; &nbsp; Los Signals reemplazan a Zone.js como el mecanismo principal para el manejo de cambios de estado.<br>&nbsp; &nbsp; Aunque Zone.js sigue disponible para casos de uso específicos (como bibliotecas de terceros), ya no es necesario para la mayoría de los escenarios.</p><p><strong>Ventajas de los Signals Sobre Zone.js</strong></p><p>&nbsp; &nbsp; 1. Eficiencia:<br>&nbsp; &nbsp; Los Signals minimizan los cambios innecesarios en la UI, optimizando el rendimiento.</p><p>&nbsp; &nbsp; 2. Previsibilidad:<br>&nbsp; &nbsp; Facilitan la comprensión de cuándo y por qué se actualiza la interfaz, reduciendo la complejidad en el desarrollo.</p><p>&nbsp; &nbsp; 3. Menor Sobrecarga:<br>&nbsp; &nbsp; Eliminar la dependencia de Zone.js reduce la necesidad de manejar zonas adicionales, aligerando la aplicación.</p><p><strong>Resumen</strong></p><p>Los Signals son una herramienta poderosa que redefine cómo Angular maneja el estado reactivo. Ofrecen:</p><p>&nbsp; &nbsp;&nbsp;<i>Mejor rendimiento.</i><br>&nbsp; &nbsp;&nbsp;<i>Una forma más clara y sencilla de rastrear y reaccionar a los cambios</i>.<br>&nbsp; &nbsp;&nbsp;<i>Compatibilidad con las necesidades modernas de desarrollo, sin perder la flexibilidad de Zone.js para casos especiales.</i></p><p>Con Signals, Angular 19 no solo moderniza su enfoque, sino que da un paso firme hacia un futuro más eficiente y predecible en el desarrollo web.</p>", "author": "Marco", "fecha": "2024-11-20", "image": "images/angular_signals_SkDRTsr.webp"}}, {"model": "blog_application.article", "pk": 3, "fields": {"title": "Angular Standalone components.", "subtitle": "Los componentes independientes de Angular", "resumen": "introducidos como una característica en Angular 14 han sido adoptados de forma predeterminada en Angular 19.", "article": "<ol><li><h3>&nbsp;Enfoque Tradicional: Basado en Módulos (Hasta Angular 13)</h3></li></ol><ul><li><p>En versiones anteriores, Angular utilizaba módulos (NgModules) como una pieza fundamental para estructurar aplicaciones. Cada componente, directiva o pipe debía declararse dentro de un módulo.</p><h3><strong>Características</strong>:</h3><p>&nbsp; &nbsp; Módulos Obligatorios:<br>&nbsp; &nbsp; &nbsp; &nbsp; Los componentes, pipes o directivas no podían existir sin declararse en un módulo.<br>&nbsp; &nbsp; &nbsp; &nbsp; Ejemplo:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; @NgModule({<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; declarations: [MyComponent],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; imports: [CommonModule],<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exports: [MyComponent]<br>&nbsp; &nbsp; &nbsp; &nbsp; })<br>&nbsp; &nbsp; &nbsp; &nbsp; export class MyModule {}</p><p><strong>&nbsp; &nbsp; Carga Declarativa:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; Los módulos definían explícitamente qué elementos estaban disponibles en cada parte de la aplicación.</p><p><strong>&nbsp; &nbsp; Complejidad Incrementada:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; En aplicaciones grandes, los módulos podían volverse complejos y difíciles de gestionar debido a las múltiples dependencias.</p><p><strong>2. Standalone Components: Desde Angular 14, Adoptados en Angular 19.</strong></p><p>Los Standalone Components eliminan la necesidad de módulos para ciertos elementos, simplificando la estructura del proyecto.</p><p><br><strong>Características:</strong></p></li><li><p>&nbsp; &nbsp; Sin Necesidad de Módulos:<br>&nbsp; &nbsp; &nbsp; &nbsp; Los componentes, pipes y directivas ahora se definen como standalone: true.<br>&nbsp; &nbsp; &nbsp; &nbsp; Ejemplo:</p><p>&nbsp; &nbsp;&nbsp;<i>@Component({</i><br><i>&nbsp; &nbsp; &nbsp; selector: 'app-standalone',</i><br><i>&nbsp; &nbsp; &nbsp; standalone: true,</i><br><i>&nbsp; &nbsp; &nbsp; template: '&lt;h1&gt;Standalone Component&lt;/h1&gt;',</i><br><i>&nbsp; &nbsp; &nbsp; imports: [CommonModule]</i><br><i>&nbsp; &nbsp; })</i><br><i>&nbsp; &nbsp; export class StandaloneComponent {}</i></p></li></ul><p><strong>&nbsp; &nbsp; 3. &nbsp; &nbsp;Declaraciones Directas:</strong></p><p>&nbsp; &nbsp; En lugar de depender de módulos, las dependencias como otros componentes o pipes se importan directamente usando la propiedad imports.</p><p>Simplificación del Router:</p><p>&nbsp; &nbsp; El sistema de enrutamiento ahora permite cargar componentes directamente sin necesidad de módulos intermedios:</p><p>&nbsp; &nbsp; &nbsp; &nbsp; const routes: Routes = [<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; { path: '', component: StandaloneComponent }<br>&nbsp; &nbsp; &nbsp; &nbsp; ];</p><p><strong>Ventajas:</strong></p><p>&nbsp; &nbsp;<strong> Reducción de Complejidad:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; Se elimina la necesidad de declarar elementos en múltiples lugares.<br>&nbsp; &nbsp;&nbsp;<strong>Mejor Rendimiento:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; Los Standalone Components cargan solo las dependencias necesarias, optimizando el rendimiento.<br>&nbsp; &nbsp;&nbsp;<strong>Mayor Flexibilidad:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; Facilita la creación de bibliotecas o componentes reutilizables.</p><p><strong>Limitaciones Iniciales (Mejoradas en Angular 19):</strong></p><p>&nbsp; &nbsp;&nbsp;<strong>Compatibilidad:</strong><br>&nbsp; &nbsp; &nbsp; &nbsp; Al principio, combinar componentes autónomos con módulos tradicionales requería ajustes. Angular 19 resuelve esto haciendo que los Standalone Components sean totalmente interoperables con los NgModules existentes.</p><p><strong>3. Angular 19: Standalone como Predeterminado</strong></p><p>En Angular 19, los Standalone Components han sido adoptados como estándar:</p><p>&nbsp; &nbsp; Ahora todos los componentes, directivas y pipes son standalone: true por defecto.<br>&nbsp; &nbsp; Esto fomenta una arquitectura más modular y reactiva.</p><hr><p>Comparación Resumida</p><figure class=\"table\" style=\"float:left;width:500px;\"><table><thead><tr><th>Características</th><th>Con Módulos</th><th>Standalone Components</th></tr></thead><tbody><tr><td>Declaración</td><td>A través de NgModules</td><td>Directamente en el componente</td></tr><tr><td>Dependencias</td><td>Se gestionan en módulos&nbsp;</td><td>Se importan en cada componente</td></tr><tr><td>Simplicidad&nbsp;</td><td>Complejo en proyectos grandes</td><td>Más simple y directo</td></tr><tr><td>Uso Predeterminado</td><td>Angular 13 y anteriores</td><td>Angular 19 en adelante</td></tr></tbody></table></figure><p>&nbsp;</p>", "author": "Marco", "fecha": "2024-11-22", "image": "images/angular_shield.webp"}}, {"model": "blog_application.article", "pk": 4, "fields": {"title": "React", "subtitle": "Que es React?", "resumen": "React es una librería basada en JavaScript y que sirve para crear componentes.", "article": "<p>Cómo funciona la creación de componentes en React?</p><p>&nbsp;</p><ol><li><p>Componentes como funciones o clases: En React, un componente es esencialmente una función de JavaScript o una clase que devuelve</p><p>una descripción de lo que se debe <i><mark class=\"marker-yellow\">renderizar&nbsp;</mark> </i>en la pantalla. Esta descripción se hace utilizando JSX<i>, </i>una sintaxis similar a HTML que nos</p><p>permite escribir estructuras de interfaz de usuario de manera mas intuitiva.</p></li><li><p>&nbsp;Componentes re-utilizables: Una vez creado el componente, este puede ser reutilizado en diferentes partes de tu aplicacion. Esto</p><p>promueve la modularidad y la organización del código.</p></li><li><p>&nbsp;Props: Los componentes pueden recibir datos a través de propiedades (props). Estas props permiten personalizar el comportamiento de</p><p>un componente según las necesidades especificas de cada instancia.</p></li><li><p>&nbsp;Estado: Los componentes también pueden tener un estado interno que puede cambiar a lo largo del tiempo esto permite crear interacciones</p><p>del usuario.</p></li></ol><p>Como se unen los componentes para crear una aplicación ?</p><ol><li><p>&nbsp;Jerarquía de componentes: Los componentes en React se organizan en una jerarquía. Un componente padre puede renderizar otros</p><p>componentes hijos, creando una estructura similar a un árbol.</p></li><li>JSX: Al utilizar JSX. puedes anidar componentes de una forma muy similar a como anidarías elementos HTML.</li><li>Props: Los componentes padres pasan props a sus componentes hijos para comunicar información y controlar su comportamiento.</li><li><p>Estado: Los cambios en el estado de un componente causan que se vuelva a renderizar y esto puede provocar que se rendericen&nbsp;</p><p>nuevamente los componentes hijos que dependen de ese estado.</p></li></ol><p>Un ejemplo sencillo:</p><pre><code class=\"language-javascript\">function Greeting(props) {\r\n  return &lt;h1&gt;Hola, {props.name}!&lt;/h1&gt;;\r\n}\r\nfunction App() {\r\n  return (\r\n    &lt;div&gt;\r\n      &lt;Greeting name=\"Mundo\" /&gt;\r\n      &lt;Greeting name=\"React\" /&gt;\r\n    &lt;/div&gt;\r\n  );\r\n}</code></pre><p><strong>En este ejemplo:</strong></p><ul><li>Greeting es un componente que recibe un nombre como prop y lo muestra en un encabezado.</li><li><p>App es el componente principal que renderiza dos instancias del componente Greeting. con diferentes nombres.</p><p>&nbsp;</p></li></ul><p><strong>Ventajas de usar componentes en React:</strong></p><ul><li>Reutilización: Los componentes pueden ser reutilizables en diferentes partes de la aplicación.</li><li>Modularización: El código se divide en partes mas pequeñas y manejables.</li><li>Facilidad de prueba: Los componentes individuales pueden ser probados de forma aislada.</li><li>Rendimiento: React utiliza un algoritmo de reconciliación virtual DOM que optimiza las actualizaciones de la interfaz de usuario.</li><li><p>Declarativo: En lugar de describir como cambiar la inerfaz de usurio, describes como debería verse.</p><p>&nbsp;</p></li></ul><p>En resumen:</p><p>React nos permite construir interfaces de usuario de forma modular y eficiente al dividir la interfaz en componentes reutilizables. Estos componentes se pueden combinar para crear aplicaciones complejas y dinámicas. La capacidad de React para gestionar el estado y renderizar de manera eficiente hace que sea una excelente opción para crear aplicaciones web modernas.\t\t</p>", "author": "Marco", "fecha": "2024-12-30", "image": "images/react_logo.png"}}, {"model": "blog_application.article", "pk": 5, "fields": {"title": "Streamlit el Framework de Python ideal para: Data Science, IA y ML", "subtitle": "", "resumen": "Streamlit facilita la creación de webapps en Python, especialmente donde el propósito es visualizar datos.", "article": "<p>Streamlit es un framework diseñado específicamente para crear aplicaciones web enfocadas en análisis de datos, visualización y machine learning (ML) de manera rápida y sencilla. Su enfoque está orientado a data scientists, ingenieros de ML y desarrolladores de IA, permitiéndoles convertir scripts de Python en aplicaciones interactivas con muy poco esfuerzo. Esto la diferencia de frameworks como React o Vue, que son más generales y requieren conocimientos avanzados de desarrollo frontend.</p><p><br>1. Fácil de usar y diseñado para Python</p><p>&nbsp; &nbsp;Streamlit permite escribir aplicaciones web utilizando solo Python. No es necesario aprender tecnologías de frontend como HTML, CSS o JavaScript.<br>&nbsp; &nbsp;Los elementos de la interfaz (botones, sliders, gráficos) se integran directamente con las bibliotecas de Python, como Pandas, Matplotlib, Plotly, y Scikit-learn.<br>&nbsp; &nbsp;Ejemplo: Con pocas líneas de código, puedes cargar un modelo de ML y permitir al usuario interactuar con los resultados.</p><p>2. Integración directa con bibliotecas de ML y visualización</p><p>&nbsp; &nbsp;Soporte nativo para bibliotecas populares como:<br>&nbsp; &nbsp; &nbsp; &nbsp;NumPy y Pandas: Manipulación de datos.<br>&nbsp; &nbsp; &nbsp; &nbsp;Matplotlib, Seaborn, Plotly, Altair: Visualización de datos.<br>&nbsp; &nbsp; &nbsp; &nbsp;Scikit-learn, TensorFlow, PyTorch: Modelos de machine learning.<br>&nbsp; &nbsp;Puedes mostrar gráficos, mapas, tablas, y otras visualizaciones sin necesidad de configurar manualmente cómo renderizarlas en la web.</p><p>3. Iteración rápida</p><p>&nbsp; &nbsp;Streamlit está diseñado para prototipado rápido. Cambias tu código, recargas el navegador y ves los resultados de inmediato.<br>&nbsp; &nbsp;Esto es crucial para data scientists que experimentan con modelos o visualizaciones y necesitan ver resultados inmediatos.</p><p>4. Despliegue sencillo</p><p>&nbsp; &nbsp;Streamlit ofrece su propia plataforma de despliegue (Streamlit Cloud), donde puedes compartir tus aplicaciones con solo subir tu código a GitHub.<br>&nbsp; &nbsp;No necesitas configurar servidores ni preocuparte por frameworks frontend.</p><p>5. Enfoque en la interactividad</p><p>&nbsp; &nbsp;Proporciona widgets como sliders, selectores, entradas de texto y más, que permiten a los usuarios interactuar directamente con el modelo o los datos.<br>&nbsp; &nbsp;Ejemplo: Un slider para ajustar hiperparámetros de un modelo y ver cómo afectan los resultados.</p><p>¿Por qué usar Streamlit en lugar de React o Vue?</p><p>&nbsp; &nbsp;Curva de aprendizaje más corta<br>&nbsp; &nbsp; &nbsp; &nbsp;React y Vue requieren conocimientos en JavaScript, CSS, y HTML, además de herramientas adicionales como Webpack o Babel.<br>&nbsp; &nbsp; &nbsp; &nbsp;Streamlit solo requiere Python, lo que lo hace mucho más accesible para quienes ya trabajan en ciencia de datos.</p><p>&nbsp; &nbsp;Desarrollo más rápido<br>&nbsp; &nbsp; &nbsp; &nbsp;Streamlit elimina la necesidad de separar backend y frontend. Puedes concentrarte exclusivamente en el análisis y la visualización.<br>&nbsp; &nbsp; &nbsp; &nbsp;React o Vue requieren la creación de APIs para comunicar el backend con el frontend, lo que aumenta la complejidad.</p><p>&nbsp; &nbsp;Diseñado específicamente para científicos de datos<br>&nbsp; &nbsp; &nbsp; &nbsp;React y Vue son frameworks generalistas para aplicaciones web. Streamlit, en cambio, está optimizado para trabajar con datos y modelos de machine learning.</p><p>&nbsp; &nbsp;Compatibilidad con herramientas científicas<br>&nbsp; &nbsp; &nbsp; &nbsp;En Streamlit, puedes integrar gráficos y resultados directamente desde herramientas científicas como Jupyter o bibliotecas de visualización. En React o Vue, tendrías que usar librerías de JavaScript como D3.js o Highcharts, que requieren más configuración.</p><p>&nbsp; &nbsp;Menor esfuerzo de despliegue<br>&nbsp; &nbsp; &nbsp; &nbsp;Una aplicación Streamlit puede desplegarse fácilmente con Streamlit Cloud, Heroku o Docker sin preocuparse por el cliente/servidor. Con React o Vue, necesitas configurar servidores para el frontend y backend por separado.</p><p>Cuándo elegir React o Vue sobre Streamlit</p><p>Aunque Streamlit es ideal para prototipos y herramientas internas, React o Vue pueden ser más apropiados si necesitas:</p><p>&nbsp; &nbsp;Una interfaz de usuario personalizada y compleja.<br>&nbsp; &nbsp;Escalar tu aplicación a una plataforma de producción para miles de usuarios.<br>&nbsp; &nbsp;Integrar tu aplicación con otros sistemas más allá de Python.</p><p>En resumen, Streamlit es una opción poderosa para proyectos de ciencia de datos e inteligencia artificial porque simplifica todo el flujo de trabajo: desde el desarrollo hasta la presentación. Mientras que frameworks como React o Vue tienen más flexibilidad para desarrolladores de frontend, Streamlit es un \"todo en uno\" para el mundo de los datos.</p>", "author": "Marco", "fecha": "2024-12-30", "image": "images/streamlitLogo.jpg"}}, {"model": "blog_application.article", "pk": 6, "fields": {"title": "Los 3 principales métodos de recomendación:", "subtitle": "Metodos que usan las empresas para recomendar sus productos o servicios:", "resumen": "La industria en general busca la forma de llegar al publico basandose en recomendaciones. Pero como se dan estas recomendaciones?", "article": "<h1>Métodos de recomendación:</h1><h3>Los principales métodos de recomendación son estos:</h3><p>&nbsp;</p><ol><li><p>&nbsp;Filtrado colaborativo:</p><p><strong>Idea central: </strong>Se basa en la premisa de que a las personas que les gustan ciertas cosas similares,</p><p>también les gustaran otras cosas similares, esto suena redundante pero es que si es redundante.</p><ul style=\"list-style-type:circle;\"><li><strong>Funcionamiento</strong><ul style=\"list-style-type:square;\"><li>Basado en usuarios: Identifica usuarios con gustos similares a ti y te recomienda lo que a ellos les gusta.<ul style=\"list-style-type:disc;\"><li><p>Por ejemplo si eres un joven español lo mas probable es que te gusten las cosas que le gustan a&nbsp;</p><p>otros jóvenes españoles.&nbsp;<br><br>Por ejemplo en YouTube si entras sin identificarte, pero estas en Sidney entonces te recomendara&nbsp;</p><p>los vídeos que estén de moda en esa zona. Pero si te identificas y eres una mujer de 35 años y que&nbsp;</p><p>vives en Colombia te recomendara vídeos que otras mujeres Colombianas de 35 años hayan visto.<br><br>Y así se va segmentado.</p></li></ul></li><li>Basado en ítems: Analiza la similitud entre los ítems (vídeos, en el caso de YouTube) y te recomienda aquellos similares a los que ya has visto o valorado positivamente.</li></ul></li></ul></li><li>Filtrado basado en contenido:<ul style=\"list-style-type:circle;\"><li><strong>Idea central</strong> : Recomienda items similares a los que el usuario ha consumido, basándose en las características pertenecientes a dichos items.<ul><li><strong>Funcionamiento:</strong><ul><li>Analiza las características de los vídeos que has visto (palabras clave, etiquetas, descripción, etc.) y te sugiere otros con características similares.<ul><li>Ejemplo en YouTube: Si has visto muchos videos de tutoriales de cocina, YouTube te recomendara otros tutoriales de cocina, o vídeos sobre cocina en general.</li></ul></li></ul></li></ul></li></ul></li><li>Híbridos:<ul style=\"list-style-type:circle;\"><li><strong>Idea central: </strong>Combinan los beneficios de los métodos anteriores para obtener resultados mas precisos y personalizados.<ul><li><strong>Funcionamiento:</strong><ul><li>Utilizan tanto la información sobre el usuario (filtrado colaborativo) como sobre el contenido (filtrado basado en contenido) para generar recomendaciones.<ul><li>Ejemplo en YouTube: YouTube podría combinar la información de que te gustan los vídeos de gatos (filtrado colaborativo) con el hecho de que los últimos vídeos que has visto es de tutoriales de tejido (filtrado basado en contenido) y recomendarte vídeos de tutoriales de tejido de suéteres con figuras de gatitos.</li></ul></li></ul></li></ul></li></ul></li></ol><p>Como funcionan en la practica?</p><p>Youtube utiliza una combinación de estos métodos, junto con otros factores como:</p><ul><li><strong>Historial de visuializacion: </strong>Los vídeos que has visto recientemente tienen un gran peso en las recomendaciones.</li><li><strong>Interacciones: </strong>Los \"me gusta\", \"no me gusta\", comentarios y el tiempo que pasas viendo un vídeo influyen en las futuras recomendaciones.</li><li><strong>Búsquedas: </strong>Las búsquedas que realizas se utilizan para personalizar aun mas las sugerencias.</li><li><strong>Características del vídeo: &nbsp;</strong>Las etiquetas, las descripción y el titulo del vídeo son analizadas para determinar su contenido:</li></ul><p><strong>En resumen. </strong>Lo sistemas de recomendación son capaces de analizar una enorme cantidad de datos para ofrecerte sugerencias cada vez mas personalizadas y relevantes. Al combinar diferentes métodos y factores, logran que cada usuario tenga una experiencia única y descubra nuevos contenidos que le puedan interesar.</p>", "author": "Marco", "fecha": "2025-01-09", "image": "images/recomendacionMetodos.webp"}}, {"model": "blog_application.article", "pk": 7, "fields": {"title": "Herramientas de Pruebas de API.", "subtitle": "Postman o Atac.", "resumen": "Dentro de las herramientas para pruebas Api existen muchas sin embargo quiero hablar de las dos que yo he probado. Postman y Atac.", "article": "<p><strong>Que son los porbadores de API's ?</strong></p><p>Los probadores de APIs como <strong>Postman</strong> y <strong>Atac</strong> se conectan a un servidor y realizan peticiones <strong>HTTP</strong> (o <strong>HTTPS</strong>). La idea principal es permitirte&nbsp;</p><p>enviar solicitudes a los endpoints de tu API y recibir las respuestas para inspeccionarlas y depurar tu aplicación.&nbsp;</p><p>Sin embargo, hay diferencias en cómo lo hacen <strong>Postman</strong> y <strong>Atac</strong>, ya que están diseñados con enfoques distintos.<br><br><strong>¿Qué hacen estas herramientas al probar APIs?</strong><br>&nbsp;</p><ol><li>&nbsp; &nbsp;Construcción de solicitudes HTTP:<ol><li> Te permiten configurar los métodos HTTP: GET, POST, PUT, DELETE, etc.</li><li>Puedes agregar headers, query parameters, cuerpos de solicitud (body) y otros detalles necesarios para que la API funcione</li></ol></li><li>Conexión al servidor:<ol><li>Envían la solicitud HTTP al endpoint de la API especificada (por ejemplo, <a href=\"https://api.example.com/users)\">https://api.example.com/users)</a></li><li>Reciben la respuesta del servidor (código de estado HTTP, cuerpo de la respuesta, headers, etc.).</li><li>Inspección de respuestas:</li></ol></li><li> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Muestran detalles como:<ol><li>Código de estado HTTP (200 OK, 404 Not Found, 500 Internal Server Error).</li><li>Datos en formato JSON, XML, texto plano, etc.</li><li>Headers de la respuesta (Content-Type, Authorization, etc.)</li></ol></li><li>Pruebas avanzadas (dependiendo de la herramienta):<ol><li>Automatización: Crear scripts o colecciones de pruebas para validar que tu API funcione correctamente en diferentes escenarios.</li><li>Documentación: Generar documentos que expliquen cómo interactuar con la API.</li><li>Autenticación: Manejar diferentes esquemas de autenticación (como OAuth, API Keys, JWT).</li></ol></li></ol><h2><strong>¿Como funciona Postman?</strong></h2><ul><li>&nbsp;Postman es grafico y amigable:<ul><li>Postman es una herramienta visual por lo que no es necesario el uso de comandos.</li></ul></li></ul>", "author": "Marco", "fecha": "2025-02-05", "image": "images/apis_try.webp"}}, {"model": "blog_application.article", "pk": 8, "fields": {"title": "Diccionarios en Python vs Objetos en JavaScript", "subtitle": "", "resumen": "Los diccionarios en Python y los objetos en JavaScript tienen muchas similitudes, lo que puede llevar a confusión entre los desarr", "article": "<h1>Diccionarios en Python vs. Objetos en JavaScript: ¿Son lo mismo?</h1><p>Los diccionarios en Python y los objetos en JavaScript tienen muchas similitudes, lo que puede llevar a confusión entre los desarrolladores que trabajan con ambos lenguajes. Sin embargo, hay diferencias clave que vale la pena conocer. En este artículo, exploraremos sus similitudes y diferencias con ejemplos prácticos.</p><h2>¿Qué son los Diccionarios en Python?</h2><p>En Python, un diccionario (<code>dict</code>) es una estructura de datos que almacena pares clave-valor. Se define con llaves <code>{}</code> y las claves deben ser inmutables (cadenas, números o tuplas).</p><p><strong>Ejemplo de un diccionario en Python:</strong></p><pre><code class=\"language-plaintext\">persona = {</code></pre><pre><code class=\"language-plaintext\">    \"nombre\": \"Juan\",</code></pre><pre><code class=\"language-plaintext\">    \"edad\": 30,</code></pre><pre><code class=\"language-plaintext\">    \"ciudad\": \"Madrid\"</code></pre><pre><code class=\"language-plaintext\">}</code></pre><pre><code class=\"language-plaintext\">print(persona[\"nombre\"])  # Output: Juan</code></pre><h2>¿Qué son los Objetos en JavaScript?</h2><p>En JavaScript, los objetos también almacenan pares clave-valor y se definen con llaves <code>{}</code>. Sin embargo, las claves son cadenas implícitamente y los objetos pueden contener funciones (métodos).</p><p><strong>Ejemplo de un objeto en JavaScript:</strong></p><pre><code class=\"language-plaintext\">const persona = {</code></pre><pre><code class=\"language-plaintext\">    nombre: \"Juan\",</code></pre><pre><code class=\"language-plaintext\">    edad: 30,</code></pre><pre><code class=\"language-plaintext\">    ciudad: \"Madrid\"</code></pre><pre><code class=\"language-plaintext\">};</code></pre><pre><code class=\"language-plaintext\">console.log(persona.nombre);  // Output: Juan</code></pre><h2>Similitudes entre Diccionarios en Python y Objetos en JavaScript</h2><p>✅ Ambos almacenan datos en pares clave-valor.<br>✅ Se accede a los valores con <code>clave[\"propiedad\"]</code> o <code>clave.propiedad</code> (en JS).<br>✅ Permiten agregar o modificar propiedades dinámicamente.</p><h2>Diferencias Clave</h2><figure class=\"table\"><table><thead><tr><th style=\"border-style:none;padding:0cm;\">Característica</th><th style=\"border-style:none;padding:0cm;\">Python (<code>dict</code>)</th><th style=\"border-style:none;padding:0cm;\">JavaScript (<code>{}</code> - objeto literal)</th></tr></thead><tbody><tr><td style=\"border-style:none;padding:0cm;\"><strong>Sintaxis</strong></td><td style=\"border-style:none;padding:0cm;\"><code>{\"clave\": valor}</code></td><td style=\"border-style:none;padding:0cm;\"><code>{clave: valor}</code> (sin comillas en claves)</td></tr><tr><td style=\"border-style:none;padding:0cm;\"><strong>Acceso a valores</strong></td><td style=\"border-style:none;padding:0cm;\"><code>dict[\"clave\"]</code> (obligatorio <code>[]</code>)</td><td style=\"border-style:none;padding:0cm;\"><code>objeto.clave</code> o <code>objeto[\"clave\"]</code></td></tr><tr><td style=\"border-style:none;padding:0cm;\"><strong>Herencia</strong></td><td style=\"border-style:none;padding:0cm;\">No tiene herencia directa</td><td style=\"border-style:none;padding:0cm;\">Usa <code>Object.prototype</code> (POO con prototipos)</td></tr><tr><td style=\"border-style:none;padding:0cm;\"><strong>Orden de elementos</strong></td><td style=\"border-style:none;padding:0cm;\">Se mantiene desde Python 3.7+</td><td style=\"border-style:none;padding:0cm;\">Se mantiene desde ES6+</td></tr><tr><td style=\"border-style:none;padding:0cm;\"><strong>Métodos internos</strong></td><td style=\"border-style:none;padding:0cm;\"><code>keys()</code>, <code>values()</code>, <code>items()</code></td><td style=\"border-style:none;padding:0cm;\"><code>Object.keys()</code>, <code>Object.values()</code></td></tr></tbody></table></figure><h2>Ejemplo de Diferencias</h2><h3>1. Acceso a Propiedades</h3><p><strong>En Python:</strong></p><pre><code class=\"language-plaintext\">persona = {\"nombre\": \"Juan\"}</code></pre><pre><code class=\"language-plaintext\">print(persona[\"nombre\"])  # Funciona</code></pre><pre><code class=\"language-plaintext\">print(persona.nombre)  # Error: los diccionarios no permiten acceso con `.`</code></pre><p><strong>En JavaScript:</strong></p><pre><code class=\"language-plaintext\">const persona = { nombre: \"Juan\" };</code></pre><pre><code class=\"language-plaintext\">console.log(persona.nombre);  // Funciona</code></pre><pre><code class=\"language-plaintext\">console.log(persona[\"nombre\"]);  // También funciona</code></pre><h3>2. Diferencias en la Serialización (JSON)</h3><p><strong>En Python:</strong></p><pre><code class=\"language-plaintext\">import json</code></pre><pre><code class=\"language-plaintext\">persona = {\"nombre\": \"Juan\"}</code></pre><pre><code class=\"language-plaintext\">print(json.dumps(persona))  # '{\"nombre\": \"Juan\"}'</code></pre><p><strong>En JavaScript:</strong></p><pre><code class=\"language-plaintext\">const persona = { nombre: \"Juan\" };</code></pre><pre><code class=\"language-plaintext\">console.log(JSON.stringify(persona));  // '{\"nombre\":\"Juan\"}'</code></pre><h2>Conclusión</h2><p>Los diccionarios en Python y los objetos en JavaScript son estructuras similares, pero no idénticas. Mientras que los <code>dict</code> son estructuras de datos puras, los objetos en JavaScript pueden formar la base de la programación orientada a objetos del lenguaje. Comprender estas diferencias es clave para evitar errores y escribir mejor código al trabajar con ambos lenguajes.</p><p>¿Tienes alguna experiencia interesante con estas diferencias? ¡Compártela en los comentarios!</p>", "author": "Marco", "fecha": "2025-02-26", "image": "images/jsvspython.jpeg"}}]